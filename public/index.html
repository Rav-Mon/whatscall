<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mango Chat - Private</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* All previous CSS styles remain exactly the same */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Helvetica, Arial, sans-serif;
        }

        :root {
            --primary-color: #128C7E;
            --primary-dark: #075E54;
            --secondary-color: #25D366;
            --chat-bg-sent: #DCF8C6;
            --chat-bg-received: #FFFFFF;
            --text-color: #303030;
            --light-text: #667781;
            --border-color: #e0e0e0;
            --online-indicator: #4ad504;
        }

        body {
            background: linear-gradient(to bottom, var(--primary-color), var(--primary-dark));
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            width: 95%;
            max-width: 1400px;
            height: 95vh;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            display: flex;
            overflow: hidden;
        }

        /* All other CSS styles from previous implementation */
        /* ... (include all the CSS from previous code) ... */

        /* WebRTC Video Elements */
        .video-container {
            width: 100%;
            max-width: 500px;
            margin: 20px auto;
            position: relative;
        }

        .video-container video {
            width: 100%;
            border-radius: 10px;
            background: #000;
        }

        .local-video {
            position: absolute;
            width: 120px;
            height: 90px;
            bottom: 10px;
            right: 10px;
            border: 2px solid white;
            border-radius: 5px;
        }

        .call-quality {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
        }

        .connection-status.connected {
            background: var(--secondary-color);
        }

        .connection-status.disconnected {
            background: #ff3b30;
        }
    </style>
</head>
<body>
    <!-- Connection Status -->
    <div class="connection-status disconnected" id="connectionStatus">
        <i class="fas fa-wifi"></i> Connecting...
    </div>

    <!-- Login Screen -->
    <div class="login-screen" id="loginScreen">
        <div class="login-container">
            <h2 class="login-title">Mango Chat</h2>
            <p>Select your user to start chatting</p>
            <div class="user-option" data-user="mango1">
                <div class="user-name">Mango 1</div>
            </div>
            <div class="user-option" data-user="mango2">
                <div class="user-name">Mango 2</div>
            </div>
            <button class="login-button" id="loginButton">Start Chatting</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="profile-header">
                <div class="profile-info">
                    <div class="profile-pic" id="userProfilePic">
                        <img src="" alt="Profile" id="profileImage">
                        <div class="change-photo">Change</div>
                    </div>
                    <div>
                        <div class="profile-name" id="userName">Mango 1</div>
                        <div class="profile-status" id="userStatus">Offline</div>
                    </div>
                </div>
                <div class="icons">
                    <div class="icon" id="statusIcon"><i class="fas fa-circle-notch"></i></div>
                    <div class="icon" id="newChatIcon"><i class="fas fa-comment-alt"></i></div>
                    <div class="icon" id="menuIcon"><i class="fas fa-ellipsis-v"></i></div>
                </div>
            </div>
            
            <div class="search-container">
                <div class="search-box">
                    <i class="fas fa-search"></i>
                    <input type="text" placeholder="Search or start new chat">
                </div>
            </div>
            
            <div class="chat-list">
                <div class="chat-item active" id="chatItem">
                    <div class="chat-avatar">
                        <img src="" alt="Mango 2" id="contactImage">
                        <div class="online-indicator" id="onlineIndicator" style="display: none;"></div>
                    </div>
                    <div class="chat-details">
                        <div class="chat-name" id="contactName">Mango 2</div>
                        <div class="chat-preview" id="chatPreview">Click to start chatting...</div>
                    </div>
                    <div class="chat-meta">
                        <div class="chat-time" id="chatTime">Now</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Chat Area -->
        <div class="chat-area">
            <div class="chat-header">
                <div class="chat-header-info">
                    <div class="chat-avatar">
                        <img src="" alt="Mango 2" id="chatContactImage">
                        <div class="online-indicator" id="chatOnlineIndicator" style="display: none;"></div>
                    </div>
                    <div>
                        <div class="chat-name" id="chatContactName">Mango 2</div>
                        <div class="profile-status" id="chatContactStatus">Offline</div>
                    </div>
                </div>
                <div class="chat-header-actions">
                    <div class="icon" id="voiceCallBtn"><i class="fas fa-phone-alt"></i></div>
                    <div class="icon" id="videoCallBtn"><i class="fas fa-video"></i></div>
                    <div class="icon" id="chatMenuBtn"><i class="fas fa-ellipsis-v"></i></div>
                </div>
            </div>
            
            <div class="messages-container" id="messagesContainer">
                <!-- Messages will be inserted here -->
            </div>
            
            <div class="message-input-container">
                <div class="input-actions">
                    <i class="fas fa-smile"></i>
                    <i class="fas fa-paperclip" id="attachButton"></i>
                </div>
                <input type="text" class="message-input" placeholder="Type a message" id="messageInput">
                <div class="send-button" id="sendButton">
                    <i class="fas fa-paper-plane"></i>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Call Screen -->
    <div class="call-screen" id="callScreen">
        <div class="caller-info">
            <div class="caller-avatar">
                <img src="" alt="Caller" id="callerImage">
            </div>
            <div class="caller-name" id="callerName">Mango 2</div>
            <div class="call-status" id="callStatus">Calling...</div>
            
            <!-- Video containers for video calls -->
            <div class="video-container" id="videoContainer" style="display: none;">
                <video id="remoteVideo" autoplay playsinline></video>
                <video id="localVideo" class="local-video" autoplay playsinline muted></video>
                <div class="call-quality" id="callQuality">Connecting...</div>
            </div>
        </div>
        <div class="call-controls">
            <div class="call-button accept-call" id="acceptCall">
                <i class="fas fa-phone"></i>
            </div>
            <div class="call-button reject-call" id="rejectCall">
                <i class="fas fa-phone-slash"></i>
            </div>
        </div>
        <div class="call-button end-call" id="endCall" style="display: none;">
            <i class="fas fa-phone-slash"></i>
        </div>
    </div>

    <script>
        // WebRTC Configuration
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Global variables
        let socket;
        let currentUser = '';
        let otherUser = '';
        let localStream;
        let remoteStream;
        let peerConnection;
        let isCallActive = false;
        let isInitiator = false;
        let currentCallType = '';

        // DOM Elements
        const connectionStatus = document.getElementById('connectionStatus');
        const loginScreen = document.getElementById('loginScreen');
        const loginButton = document.getElementById('loginButton');
        const userOptions = document.querySelectorAll('.user-option');
        const userStatus = document.getElementById('userStatus');
        const onlineIndicator = document.getElementById('onlineIndicator');
        const chatOnlineIndicator = document.getElementById('chatOnlineIndicator');
        const chatContactStatus = document.getElementById('chatContactStatus');
        const voiceCallBtn = document.getElementById('voiceCallBtn');
        const videoCallBtn = document.getElementById('videoCallBtn');
        const callScreen = document.getElementById('callScreen');
        const callStatus = document.getElementById('callStatus');
        const acceptCall = document.getElementById('acceptCall');
        const rejectCall = document.getElementById('rejectCall');
        const endCall = document.getElementById('endCall');
        const videoContainer = document.getElementById('videoContainer');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const callQuality = document.getElementById('callQuality');

        // Initialize WebRTC
        async function initializeWebRTC() {
            try {
                // Request camera and microphone permissions
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                localVideo.srcObject = localStream;
                console.log('Media devices accessed successfully');
            } catch (error) {
                console.warn('Error accessing media devices:', error);
            }
        }

        // Create peer connection
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(configuration);
            
            // Add local stream to connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }
            
            // Handle incoming stream
            peerConnection.ontrack = (event) => {
                remoteStream = event.streams[0];
                remoteVideo.srcObject = remoteStream;
                updateCallQuality('Connected');
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', {
                        target: otherUser,
                        candidate: event.candidate
                    });
                }
            };
            
            // Connection state handling
            peerConnection.onconnectionstatechange = () => {
                updateCallQuality(peerConnection.connectionState);
            };
        }

        // Update call quality display
        function updateCallQuality(status) {
            const statusMap = {
                'connected': 'âœ… Excellent',
                'checking': 'ðŸ”„ Connecting...',
                'completed': 'âœ… Connected',
                'disconnected': 'âš ï¸ Poor Connection',
                'failed': 'âŒ Failed',
                'new': 'ðŸ”„ Starting...'
            };
            
            callQuality.textContent = statusMap[status] || status;
        }

        // Initialize socket connection
        function initializeSocket() {
            // Connect to signaling server (same domain for Render)
            socket = io();
            
            socket.on('connect', () => {
                connectionStatus.className = 'connection-status connected';
                connectionStatus.innerHTML = '<i class="fas fa-wifi"></i> Connected';
                console.log('Connected to signaling server');
            });
            
            socket.on('disconnect', () => {
                connectionStatus.className = 'connection-status disconnected';
                connectionStatus.innerHTML = '<i class="fas fa-wifi"></i> Disconnected';
            });
            
            // WebRTC signaling handlers
            socket.on('offer', async (data) => {
                console.log('Received offer from:', data.caller.username);
                await handleIncomingCall(data);
            });
            
            socket.on('answer', async (data) => {
                console.log('Received answer from:', data.callee.username);
                await peerConnection.setRemoteDescription(data.answer);
            });
            
            socket.on('ice-candidate', async (candidate) => {
                await peerConnection.addIceCandidate(candidate);
            });
            
            // Call management
            socket.on('incoming-call', async (data) => {
                console.log('Incoming call from:', data.from.username);
                showIncomingCall(data);
            });
            
            socket.on('call-accepted', async (data) => {
                console.log('Call accepted');
                await peerConnection.setRemoteDescription(data.answer);
                startCall();
            });
            
            socket.on('call-rejected', (data) => {
                console.log('Call rejected:', data.reason);
                endCallHandler('Call rejected');
            });
            
            socket.on('call-ended', () => {
                console.log('Call ended by other user');
                endCallHandler('Call ended');
            });
            
            // User status
            socket.on('user-online', (userData) => {
                if (userData.username === otherUser) {
                    updateUserStatus(true);
                }
            });
            
            socket.on('user-offline', (userData) => {
                if (userData.username === otherUser) {
                    updateUserStatus(false);
                }
            });
            
            // Messaging
            socket.on('new-message', (messageData) => {
                if (messageData.sender === otherUser) {
                    addMessage('received', messageData.text, new Date(messageData.timestamp));
                }
            });
        }

        // Handle incoming call
        async function handleIncomingCall(data) {
            createPeerConnection();
            await peerConnection.setRemoteDescription(data.offer);
            
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            socket.emit('answer', {
                target: data.caller.username,
                answer: answer
            });
        }

        // Show incoming call UI
        function showIncomingCall(data) {
            currentCallType = data.callType;
            isInitiator = false;
            
            callStatus.textContent = `Incoming ${currentCallType} call...`;
            callScreen.style.display = 'flex';
            
            if (currentCallType === 'video') {
                videoContainer.style.display = 'block';
            }
        }

        // Start a call
        async function startCall() {
            isCallActive = true;
            callStatus.textContent = `${currentCallType.charAt(0).toUpperCase() + currentCallType.slice(1)} call connected`;
            
            if (isInitiator) {
                acceptCall.style.display = 'none';
                rejectCall.style.display = 'none';
            }
            endCall.style.display = 'flex';
            
            if (currentCallType === 'video') {
                videoContainer.style.display = 'block';
                localVideo.srcObject = localStream;
            }
        }

        // Initiate a call
        async function initiateCall(callType) {
            if (!socket || !socket.connected) {
                alert('Not connected to server. Please refresh and try again.');
                return;
            }
            
            currentCallType = callType;
            isInitiator = true;
            
            callStatus.textContent = 'Calling...';
            callScreen.style.display = 'flex';
            
            if (callType === 'video') {
                videoContainer.style.display = 'block';
            }
            
            try {
                createPeerConnection();
                
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                socket.emit('call-user', {
                    target: otherUser,
                    offer: offer,
                    callType: callType
                });
                
                // Set timeout for no answer
                setTimeout(() => {
                    if (!isCallActive) {
                        endCallHandler('No answer');
                    }
                }, 30000);
                
            } catch (error) {
                console.error('Error creating offer:', error);
                endCallHandler('Call failed');
            }
        }

        // Accept incoming call
        async function acceptIncomingCall() {
            try {
                createPeerConnection();
                
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                socket.emit('accept-call', {
                    from: otherUser,
                    answer: offer
                });
                
                startCall();
            } catch (error) {
                console.error('Error accepting call:', error);
                endCallHandler('Call failed');
            }
        }

        // Reject incoming call
        function rejectIncomingCall() {
            socket.emit('reject-call', {
                from: otherUser,
                reason: 'User rejected call'
            });
            endCallHandler('Call rejected');
        }

        // End call handler
        function endCallHandler(reason) {
            isCallActive = false;
            callScreen.style.display = 'none';
            videoContainer.style.display = 'none';
            
            // Stop all tracks
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // Notify other user
            if (socket && socket.connected) {
                socket.emit('end-call', { target: otherUser });
            }
            
            // Add call log to chat
            if (reason !== 'Call rejected' && reason !== 'No answer') {
                addMessage('system', `${currentCallType} call ${reason}`, new Date());
            }
            
            // Reinitialize media for next call
            setTimeout(initializeWebRTC, 1000);
        }

        // Update user status
        function updateUserStatus(isOnline) {
            const statusText = isOnline ? 'Online' : 'Offline';
            const indicatorDisplay = isOnline ? 'block' : 'none';
            
            userStatus.textContent = statusText;
            chatContactStatus.textContent = statusText;
            onlineIndicator.style.display = indicatorDisplay;
            chatOnlineIndicator.style.display = indicatorDisplay;
            
            // Enable/disable call buttons based on online status
            voiceCallBtn.style.opacity = isOnline ? '1' : '0.5';
            videoCallBtn.style.opacity = isOnline ? '1' : '0.5';
        }

        // Send message
        function sendMessage() {
            const text = document.getElementById('messageInput').value.trim();
            if (text === '') return;
            
            const messageData = {
                text: text,
                sender: currentUser,
                timestamp: new Date().getTime(),
                receiver: otherUser
            };
            
            socket.emit('send-message', messageData);
            addMessage('sent', text, new Date());
            document.getElementById('messageInput').value = '';
        }

        // Add message to UI
        function addMessage(type, text, timestamp) {
            const messagesContainer = document.getElementById('messagesContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message message-${type}`;
            
            const timeString = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div>${text}</div>
                <div class="message-time">${timeString}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // User login
        function handleLogin() {
            const selectedUser = document.querySelector('.user-option.active');
            if (!selectedUser) {
                alert('Please select a user');
                return;
            }
            
            currentUser = selectedUser.dataset.user;
            otherUser = currentUser === 'mango1' ? 'mango2' : 'mango1';
            
            // Update UI
            document.getElementById('userName').textContent = currentUser === 'mango1' ? 'Mango 1' : 'Mango 2';
            document.getElementById('contactName').textContent = otherUser === 'mango1' ? 'Mango 1' : 'Mango 2';
            document.getElementById('chatContactName').textContent = otherUser === 'mango1' ? 'Mango 1' : 'Mango 2';
            document.getElementById('callerName').textContent = otherUser === 'mango1' ? 'Mango 1' : 'Mango 2';
            
            // Set profile images
            const profileImages = {
                mango1: 'https://i.pravatar.cc/150?img=1',
                mango2: 'https://i.pravatar.cc/150?img=2'
            };
            
            document.getElementById('profileImage').src = profileImages[currentUser];
            document.getElementById('contactImage').src = profileImages[otherUser];
            document.getElementById('chatContactImage').src = profileImages[otherUser];
            document.getElementById('callerImage').src = profileImages[otherUser];
            
            // Hide login screen
            loginScreen.style.display = 'none';
            
            // Login to socket
            socket.emit('user-login', {
                username: currentUser,
                userId: socket.id
            });
            
            // Add welcome message
            addMessage('system', `You and ${otherUser === 'mango1' ? 'Mango 1' : 'Mango 2'} are now connected. Start chatting!`, new Date());
        }

        // Event listeners
        document.getElementById('loginButton').addEventListener('click', handleLogin);
        userOptions.forEach(option => {
            option.addEventListener('click', () => {
                userOptions.forEach(opt => opt.classList.remove('active'));
                option.classList.add('active');
            });
        });

        document.getElementById('sendButton').addEventListener('click', sendMessage);
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        voiceCallBtn.addEventListener('click', () => initiateCall('voice'));
        videoCallBtn.addEventListener('click', () => initiateCall('video'));
        acceptCall.addEventListener('click', acceptIncomingCall);
        rejectCall.addEventListener('click', rejectIncomingCall);
        endCall.addEventListener('click', () => endCallHandler('ended'));

        // Initialize app
        async function initApp() {
            initializeSocket();
            await initializeWebRTC();
        }

        // Start the app
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
